esphome:
  name: manifoldtemperature
  friendly_name: ManifoldTemperature

esp32:
  board: esp32dev
  framework:
    type: esp-idf
    

#github.com/Vortitron/WIZ820io_w5500_esphome_patch   

external_components:
  - source:
      type: git
      url: https://github.com/Vortitron/WIZ820io_w5500_esphome_patch2
      ref: main
    components: [ethernet_patch]
    refresh: always

ethernet_patch:

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "CYM+X3tIAeAaIWson+NrIoSV3KJQrK2oGOJ9K+OnfOk="

ota:
  - platform: esphome
    password: "d5db3b91c9f86717fe13391851a90b79"

# Ethernet configuration with built-in support (now using your forked IDF)
ethernet:
  type: W5500
  mosi_pin: GPIO13
  miso_pin: GPIO12
  clk_pin: GPIO14
  cs_pin: GPIO15
  reset_pin: GPIO26
  interrupt_pin: GPIO27
  clock_speed: 12MHz

# 1-Wire setup for DS18B20
one_wire:
  - platform: gpio
    pin: GPIO4

# Define sensors
sensor:
  - platform: dallas_temp
    id: manifold_input_temp
    name: "Manifold Input Temp"
    address: "0x170000007bc02828"  # Adjust after mapping
    update_interval: 31s   # 60/2=30, +1 for prime
    filters:
      - filter_out: nan
      - timeout: 5min
  - platform: dallas_temp
    id: loop_1_return_temp
    name: "Loop 1 Return Temp"
    address: "0x7b0000007a769928"    # Adjust after mapping
    update_interval: 33s   # 66/2=33, next prime is 37
    filters:
      - filter_out: nan
      - timeout: 5min
  - platform: dallas_temp
    id: loop_2_return_temp
    name: "Loop 2 Return Temp"
    address: "0x780000007a859c28"    # Adjust after mapping
    update_interval: 37s   # 72/2=36, next prime is 37
    filters:
      - filter_out: nan
      - timeout: 5min
  - platform: dallas_temp
    id: loop_3_return_temp
    name: "Loop 3 Return Temp"
    address: "0x8300000077cf3e28"    # Adjust after mapping
    update_interval: 41s   # 78/2=39, next prime is 41
    filters:
      - filter_out: nan
      - timeout: 5min
  - platform: dallas_temp
    id: loop_4_return_temp
    name: "Loop 4 Return Temp"
    address: "0x0e000000788c2b28"    # Adjust after mapping
    update_interval: 43s   # 84/2=42, next prime is 43
    filters:
      - filter_out: nan
      - timeout: 5min
  - platform: dallas_temp
    id: loop_5_return_temp
    name: "Loop 5 Return Temp"
    address: "0x430000007852bb28"    # Adjust after mapping
    update_interval: 29s   # 90/2=45, next prime is 47
    filters:
      - filter_out: nan
      - timeout: 5min
  - platform: dallas_temp
    id: loop_6_return_temp
    name: "Loop 6 Return Temp"
    address: "0xaa000000788bcf28"    # Adjust after mapping
    update_interval: 31s   # 96/2=48, prev prime is 47
    filters:
      - filter_out: nan
      - timeout: 5min
  - platform: dallas_temp
    id: loop_7_return_temp
    name: "Loop 7 Return Temp"
    address: "0xb30000007bfe9f28"    # Adjust after mapping
    update_interval: 32s   # 102/2=51, next prime is 53
    filters:
      - filter_out: nan
      - timeout: 5min
  - platform: dallas_temp
    id: loop_8_return_temp
    name: "Loop 8 Return Temp"
    address: "0x060000007cf13f28"    # Adjust after mapping
    update_interval: 33s   # 108/2=54, prev prime is 53
    filters:
      - filter_out: nan
      - timeout: 5min
  - platform: dallas_temp
    id: air_temp
    name: "Air Temp"
    address: "0xde0000007c3ac428"    # Adjust after mapping
    update_interval: 29s   # 114/2=57, next prime is 59
    filters:
      - filter_out: nan
      - timeout: 5min
  - platform: dallas_temp
    id: boiler_temp
    name: "Hot Water Boiler Temp"
    address: "0xbc0000006a8e5228"    # Adjust after mapping - run esphome to discover
    update_interval: 23s
    filters:
      - filter_out: nan
      - timeout: 5min
  
  # Virtual sensor: Lowest loop return temperature
  - platform: template
    name: "Lowest Loop Return Temp"
    id: lowest_loop_temp
    unit_of_measurement: "Â°C"
    accuracy_decimals: 1
    device_class: temperature
    state_class: measurement
    update_interval: 30s
    lambda: |-
      std::vector<sensor::Sensor*> sensors = {
        id(loop_1_return_temp), id(loop_2_return_temp), id(loop_3_return_temp),
        id(loop_4_return_temp), id(loop_5_return_temp), id(loop_6_return_temp),
        id(loop_7_return_temp), id(loop_8_return_temp)
      };
      float min_temp = NAN;
      bool found_valid = false;
      for (auto* sensor : sensors) {
        if (sensor && sensor->state != NAN) {
          if (!found_valid || sensor->state < min_temp) {
            min_temp = sensor->state;
            found_valid = true;
          }
        }
      }
      return min_temp;
  
  # MQ2 Gas Sensor - Raw Analog Voltage
  - platform: adc
    pin: GPIO34
    id: mq2_analog_raw
    unit_of_measurement: "V"
    accuracy_decimals: 3
    update_interval: 2s
    attenuation: 11db  # Allows reading 0-3.3V range
    internal: true  # Hide raw voltage from HA
    filters:
      - sliding_window_moving_average:
          window_size: 15
          send_every: 5
  
  # MQ2 Gas Sensor - Percentage (template sensor to avoid device_class conflict)
  - platform: template
    name: "MQ2 Gas/Smoke Level"
    id: mq2_analog
    unit_of_measurement: "%"
    accuracy_decimals: 1
    update_interval: 2s
    lambda: |-
      if (id(mq2_analog_raw).state != NAN) {
        // Convert voltage (0-3.3V) to percentage (0-100%)
        float percentage = (id(mq2_analog_raw).state / 3.3) * 100.0;
        // Clamp between 0-100%
        if (percentage < 0.0) return 0.0;
        if (percentage > 100.0) return 100.0;
        return percentage;
      }
      return NAN;

# TM1638 Display and LED/Button Controller (Unchanged Pins)
display:
  - platform: tm1638
    id: tm_display
    stb_pin: GPIO19
    clk_pin: GPIO5
    dio_pin: GPIO18
    update_interval: 1s
    intensity: 7  # 0-7, adjust brightness
    lambda: |-
      auto now = id(last_button_press) + 10000; // 10-second timeout
      // Create a vector of sensor pointers for indexing
      std::vector<sensor::Sensor*> sensors = {
        id(loop_1_return_temp), id(loop_2_return_temp), id(loop_3_return_temp),
        id(loop_4_return_temp), id(loop_5_return_temp), id(loop_6_return_temp),
        id(loop_7_return_temp), id(loop_8_return_temp)
      };
      // Initialize led_states if not already set
      static bool led_states_initialized = false;
      if (!led_states_initialized) {
        for (int i = 0; i < 8; i++) {
          id(led_states)[i] = false;
        }
        led_states_initialized = true;
      }
      static unsigned long last_flash = 0;
      if (millis() - last_flash > 500) { // Flash every 500ms
        for (int i = 0; i < 8; i++) {
          if (sensors[i] && sensors[i]->state != NAN && sensors[i]->state < 5.0) {
            id(led_states)[i] = !id(led_states)[i]; // Toggle for flashing
          } else {
            id(led_states)[i] = false; // Off if in range
          }
          it.set_led(i, id(led_states)[i]); // Zero-indexed LEDs (0-7)
        }
        last_flash = millis();
      }
      if (id(display_index) > 0 && id(display_index) <= 8 && millis() < now) {
        // Show selected loop temperature - INVERTED LED (all on except selected)
        if (sensors[id(display_index) - 1] && sensors[id(display_index) - 1]->state != NAN) {
          it.printf("%04.1fC", sensors[id(display_index) - 1]->state);  // Left 4 digits
          char air_temp_str[7];
          snprintf(air_temp_str, sizeof(air_temp_str), "%04.1fC", id(air_temp)->state);
          it.print(4, air_temp_str);                                // Right 4 digits with "C"
          // Inverted LED logic - all on except the selected one
          for (int i = 0; i < 8; i++) {
            it.set_led(i, i != (id(display_index) - 1));           // All on except selected
          }
        } else {
          it.print("----");
          char air_temp_str[7];
          snprintf(air_temp_str, sizeof(air_temp_str), "%04.1fC", id(air_temp)->state);
          it.print(4, air_temp_str);                                // Show Air Temp if loop fails
          // Inverted LED logic even on error
          for (int i = 0; i < 8; i++) {
            it.set_led(i, i != (id(display_index) - 1));
          }
        }
      } else {
        // Normal mode: Show Manifold Input and Air Temp
        if (id(manifold_input_temp) && id(manifold_input_temp)->state != NAN && id(air_temp) && id(air_temp)->state != NAN) {
          it.printf("%04.1fC", id(manifold_input_temp)->state);      // Left 4 digits for Manifold
          char air_temp_str[7];
          snprintf(air_temp_str, sizeof(air_temp_str), "%04.1fC", id(air_temp)->state);
          it.print(4, air_temp_str);                               // Right 4 digits for Air with "C"
        } else {
          it.print("----");
          it.print(4, "----");                                    // Fallback if sensors fail
        }
        // Normal mode: Show status on LEDs
        // LED 0: Boiler Control Available/Connected
        it.set_led(0, id(boiler_available));
        // LED 1: Boiler Relay 1
        it.set_led(1, id(boiler_relay_1).state);
        // LED 2: Boiler Relay 2
        it.set_led(2, id(boiler_relay_2).state);
        // LED 3: Smoke/Gas Alarm (ON when smoke/gas detected, flashing for attention)
        static unsigned long last_alarm_flash = 0;
        static bool alarm_led_state = false;
        if (id(mq2_digital).state) {
          // Alarm active - flash LED rapidly
          if (millis() - last_alarm_flash > 250) {
            alarm_led_state = !alarm_led_state;
            last_alarm_flash = millis();
          }
          it.set_led(3, alarm_led_state);
        } else {
          // No alarm - LED off
          it.set_led(3, false);
        }
        // LEDs 4-7: Available for future use
        for (int i = 4; i < 8; i++) {
          it.set_led(i, false);
        }
      }

# Button Inputs via TM1638
binary_sensor:
  - platform: tm1638
    name: "Button S1"
    id: button_s1
    key: 0  # Zero-indexed (S1 = key 0)
    on_press:
      - lambda: |-
          id(display_index) = 1;
          id(last_button_press) = millis();
  - platform: tm1638
    name: "Button S2"
    id: button_s2
    key: 1  # Zero-indexed (S2 = key 1)
    on_press:
      - lambda: |-
          id(display_index) = 2;
          id(last_button_press) = millis();
  - platform: tm1638
    name: "Button S3"
    id: button_s3
    key: 2  # Zero-indexed (S3 = key 2)
    on_press:
      - lambda: |-
          id(display_index) = 3;
          id(last_button_press) = millis();
  - platform: tm1638
    name: "Button S4"
    id: button_s4
    key: 3  # Zero-indexed (S4 = key 3)
    on_press:
      - lambda: |-
          id(display_index) = 4;
          id(last_button_press) = millis();
  - platform: tm1638
    name: "Button S5"
    id: button_s5
    key: 4  # Zero-indexed (S5 = key 4)
    on_press:
      - lambda: |-
          id(display_index) = 5;
          id(last_button_press) = millis();
  - platform: tm1638
    name: "Button S6"
    id: button_s6
    key: 5  # Zero-indexed (S6 = key 5)
    on_press:
      - lambda: |-
          id(display_index) = 6;
          id(last_button_press) = millis();
  - platform: tm1638
    name: "Button S7"
    id: button_s7
    key: 6  # Zero-indexed (S7 = key 6)
    on_press:
      - lambda: |-
          id(display_index) = 7;
          id(last_button_press) = millis();
  - platform: tm1638
    name: "Button S8"
    id: button_s8
    key: 7  # Zero-indexed (S8 = key 7)
    on_press:
      - lambda: |-
          id(display_index) = 8;
          id(last_button_press) = millis();
  
  # MQ2 Gas Sensor - Software Alarm (based on analog percentage)
  # Uses hysteresis to prevent oscillation: triggers at 25%, clears at 20%
  - platform: template
    id: mq2_digital
    name: "MQ2 Smoke/Gas Alarm"
    device_class: smoke
    lambda: |-
      static bool alarm_state = false;
      if (id(mq2_analog).state != NAN) {
        if (id(mq2_analog).state >= 25.0) {
          alarm_state = true;   // Trigger at 25%
        } else if (id(mq2_analog).state <= 20.0) {
          alarm_state = false;  // Clear at 20%
        }
        // Between 20-25% it maintains previous state (hysteresis)
      }
      return alarm_state;
    filters:
      - delayed_on: 2s  # Must be high for 2s to trigger (prevents spikes)
      - delayed_off: 10s  # Stays on for 10s after clearing (latching)
  
  # Import Home Assistant switch states for LED display
  - platform: homeassistant
    id: boiler_relay_1
    entity_id: switch.boilercontrol_boiler_relay_1
    on_state:
      then:
        - lambda: |-
            id(boiler_available) = true;
    internal: true
  - platform: homeassistant
    id: boiler_relay_2
    entity_id: switch.boilercontrol_boiler_relay_2
    internal: true

# Globals for display and LED state
globals:
  - id: display_index
    type: int
    restore_value: no
    initial_value: '0'
  - id: last_button_press
    type: int
    restore_value: no
    initial_value: '0'
  - id: led_states
    type: std::array<bool, 8>
    restore_value: no
  - id: boiler_available
    type: bool
    restore_value: no
    initial_value: 'false'